<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Memcached源代码解析 | hejiajie的博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Memcached源代码解析</h1><a id="logo" href="/.">hejiajie的博客</a><p class="description">程序猿一枚</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Memcached源代码解析</h1><div class="post-meta">Mar 21, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>Memcached源代码阅读笔记</p>
<a id="more"></a>
<h2 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h2><p>建立并初始化event_base</p>
<p>prefix_stats 初始化<br>assoc_init -&gt; primary_hashtable 初始化<br>conn_init connection array初始化</p>
<p>slabs_init 初始化slabs，确定每个slab的大小以及每个chunk的size大小</p>
<p>当服务器close一个连接时，若client端接着发送数据那么就会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，进程必须捕获它并默认执行terminate，无论是否忽略该信号都会系统都会给出EPIPE错误。</p>
<p>memcached_thread_init() 初始化工作线程，对于每个线程都有fd[2] 然后pipe()将两个fd绑定起来，之后调用set_thread() 将notify_reveive_fd的事件(EV_READ|EV_PERSIT)注册到event_base中，每一个工作线程都会有一个event_base。<br>而event触发的执行函数是thread_libevent_process.</p>
<p>slabs_init()<br>memcached在启动的时候会一次性地向内存申请一大块内存，默认是64M。之后存储就是在这一大块内存中进行，减少了系统调用 增加了速度。memcached基于这块内存进行使用和管理，定义了内存块的概念，每一块默认为1M。之后再对每一个内存块划分为chunk，每一个1M内存块内的chunk的大小都是相同的，但是不同的内存块之前大小是不等的，这就需要factor来确定，而这使用slabclass来存储所有的类型。memcached是用来存储key-value结构的，用item数据结构来表示key-value。那么memcached中最小粒度的chunk就是用来存储key-value的(item), 对内存划分的行为都会造成一定量的内存浪费，但这便于对内存进行管理。</p>
<p>create_worker() 创建worker线程，每个worker线程都是执行的work_lievent函数。可以看到在worker线程里面最后仍然是调用event_base_loop()来执行事件的监听的。</p>
<p>start_assoc_maintenance_init() 创建一个线程来负责维护哈希表的内容，执行assoc_maintenance_thread函数</p>
<p>start_item_crawler_thread() memcached会开一个单独的线程对失效的缓存数据进行处理 默认关闭的</p>
<p>start_lru_maintainer_thread() memcached会开一个单独的线程来管理LRU队列的转换，HOT_LRU, WARM_LRU, COLD_LRU, NPEXP_LRU<br>遵循如下规则：</p>
<ol>
<li><p>从内存池中新分配的item，将其放入HOT_LRU队列。</p>
</li>
<li><p>HOT_LRU队列中数据量超过阀值，则转移到COLD_LRU队列。</p>
</li>
<li><p>WARM_LRU队列中数据量超过阀值，则转移到COLD_LRU队列。</p>
</li>
<li><p>如果COLD_LRU队列中数据被访问过，则转移到WARM_LRU队列。</p>
</li>
<li><p>如果HOT_LRU或WARM_LRU队列中数据被访问过，则移到队列的首部。</p>
</li>
<li><p>当从内存池中分配item时，如果item未设置exptime并且程序配置为“不踢掉exptime为0的数据”，就将其放入NOEXP_LRU队列。这个队列中的数据不会被踢掉，也不会迁移到其他队列。</p>
</li>
<li><p>如果“当内存不够用时允许踢数据”，则COLD_LRU中的数据会被回收到内存池。</p>
</li>
</ol>
<p>7,8,9 还有可能是item直接被删除掉，例如数据过期，执行delete操作，执行flush all操作。<br>如果程序允许”踢掉exptime为0的数据“，那么没有6号线，所以exptime为0的数据也将进入其他状态转换。</p>
<p>根据settings.socketpath的设置开启以下两种服务模式的一种：</p>
<pre><code>1. 以Unix域套接字的方式接受客户的请求
2. 以TCP/UDP套接字的方式接受客户的请求
</code></pre><p>server_sockets()通过调用server_socket()创建一个socket</p>
<p>如果是来了新的请求的话是调用dispatch_conn_new()分配给一个worker_thread进行处理，在一开始的时候也会判断如果是UDP模式的话那么也会调用dispatch_conn_new()给每个worker_thread分配一个UDP fd，而如果不是UDP的那么就会调用conn_new() 非UDP的是在main thread监听请求的</p>
<p>*从这里开始就memcached就开始监听外面的请求了*</p>
<p>下面主要针对TCP连接来分析memcached处理客户端的流程 </p>
<p>这个要移动到上面的 start_conn_timeout_thread 开一个线程专门负责idle connection 必须是TCP连接 current_time - c-&gt; last_cmd_time &gt; settings.idle_timeout 如果满足的话那么就会给c-&gt;thread-&gt;notify_send_fd 发送一个TIMEOUT_MSG_SIZE大小的buf [‘t’, sizeof(int)]<br>当write成功之后就会触发thread_libevent_process()处理该事件，调用conn_close_idle()接口来关闭一个idle connection</p>
<p>之前对于监听socket的初始化之后，socket是处于conn_listening状态的，正在监听请求, 当客户端和memcached建立TCP连接之后，主线程就会调用dispatch_conn_new来把该请求分配的选中的worker_thread，被选中的线程就会执行在libevent注册的回调函数thread_libevent_process(), 因为唤醒worker_thread是往对应的socket写一个字符的，那么这时候就可以字符来判断到底是发生了什么事件。当有新连接进来的时候是字符‘c’，那么就从conn_queue中pop出item，为进来的连接创建conn，注册event_handler事件响应函数,因为在conn_new的时候状态是conn_new_cmd 那么就根据c-&gt;rbyte来设置状态是conn_waiting还是conn_parse_cmd,读取命令的时候状态是conn_read，如果是UDP的就调用try_read_udp() 否则的话就调用try_read_network()，read会尽可能的多读数据，如果读取的数据超过现在的rbuf那么系统会将大小扩大到2倍。当读取完数据之后就会将状态设置为conn_parse_cmd，之后就会进行解析命令。<br>   在conn_parse_cmd就开始执行命令的过程，直接调用try_read_command()来处理命令。在try_read_command()首先会对buffer里的待处理的数据进行定位，根据’\r\n’定位到尾部，而c-&gt;rbuf指向的就是字符串的首部，这里通过’\0’来定位字符串结束的地方。<br>   确定了命令的字符串内容，那么就是处理命令了，调用process_command()。</p>
<p>tokenize_command()是将字符串进行符号化，如：<br>“set key 3 0 10” 那么就会符号化为”set”,”key”,”3”,”0”,”10”,这些都是被称作token会保存在tokens[]里面，而ntokens保存tokens的数量。<br>之后就会根据tokens[0]和tokens的长度判断出是哪一种命令然后执行相应的动作，这里我就以get和set为例子分析下memcached处理的流程。<br> 当确定收到的是get/gets命令的时候就直接调用process_get_command()执行查询工作。<br> process_get_command()-&gt;item_get()-&gt;hash()-&gt;do_item_get()-&gt;assoc_find()-&gt;item_is_flushed()<br>如果找到结果的话那么就会构建回复client的回复内容：<br>回复的内容由msglist+iov组成：<br>msglist-&gt;msghdr[] iov-&gt;iovec[] mshdr指向对应的第一个iovec地址，而msghdr也保存着含有几个iovec<br>构造好回复内容之后将状态设置为conn_mwrite,调用transmit()-&gt;sendmsg()来发送刚才组装的消息,如果一切顺利的话那么就会重新把状态设置为conn_new_cmd。</p>
<p>然后我们按照set的命令再分析一次，诸如set/update等会涉及到更新操作的都是直接调用process_update_command()来操作的。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/03/21/Memcached源码笔记/" data-id="cj1m42dxw0002n2xhz000t3v1" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2017/04/07/设计模式之1--简单工厂模式/" class="pre">设计模式之1--简单工厂模式</a><a href="/2017/03/20/hello-world/" class="next">Hello World</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/04/17/设计模式之12--代理模式/">设计模式之12--代理模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/14/设计模式之9 -- 装饰模式/">设计模式之9--装饰者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/14/设计模式之11 -- 组合模式/">设计模式之11--组合模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/13/设计模式之10 -- 桥接模式/">设计模式之10--桥接模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/12/设计模式之8 -- 适配器模式/">设计模式之8 -- 适配器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/12/设计模式之7 -- 外观模式/">设计模式之7 -- 外观模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/11/设计模式之6 -- 建造者模式/">设计模式之6 -- 建造者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/10/设计模式之5--原型模式/">设计模式之5 -- 原型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/09/设计模式之4--单例模式/">设计模式之4--单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/08/设计模式之3--抽象工厂模式/">设计模式之3--抽象工厂模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/charce1989" title="我的博客" target="_blank">我的博客</a><ul></ul><a href="http://blog.csdn.net/qq_30198509" title="江波的博客" target="_blank">江波的博客</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">hejiajie的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>